{"version":3,"sources":["../node_modules/crocks/core/implements.js","../node_modules/crocks/core/isArray.js","../node_modules/crocks/core/isFunction.js","../node_modules/crocks/core/isObject.js","../node_modules/crocks/core/isString.js","../node_modules/crocks/core/isSymbol.js","../node_modules/crocks/core/inspect.js","../node_modules/crocks/core/types.js","../node_modules/crocks/core/flNames.js","../node_modules/crocks/core/curry.js","../node_modules/crocks/core/type.js","../node_modules/crocks/core/isSameType.js","../node_modules/crocks/core/isSame.js","../node_modules/crocks/core/hasAlg.js","../node_modules/crocks/core/equals.js","../node_modules/crocks/core/isFunctor.js","../node_modules/crocks/core/isApply.js","../node_modules/crocks/core/isApplicative.js","../node_modules/crocks/core/isSemigroup.js","../node_modules/crocks/core/Pair.js","../node_modules/crocks/core/Unit.js","../node_modules/crocks/State/index.js","../node_modules/crocks/helpers/curry.js","../node_modules/crocks/helpers/compose.js","../node_modules/crocks/core/isNil.js","../node_modules/crocks/helpers/mapProps.js","data/helpers.js","data/model/answer.js","index.js"],"names":["modify","State","inc","x","dec","clamp","min","max","Math","clampAfter","fn","over","key","limitMoves","decLeft","incMoves","state","console","log","chain","execWith"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtCA;;AACA;;AACA;;AACA;;;;;;IAEQA,SAAUC,eAAVD,QAER;;AACO,IAAME,GAAG,GAAG,SAANA,GAAM,CAAAC,CAAC;AAAA,SAAIA,CAAC,IAAI,CAAT;AAAA,CAAb,EAEP;;;;;AACO,IAAMC,GAAG,GAAG,SAANA,GAAM,CAAAD,CAAC;AAAA,SAAIA,CAAC,IAAI,CAAT;AAAA,CAAb,EAEP;;;;;AACO,IAAME,KAAK,GAAG,SAARA,KAAQ,CAACC,GAAD,EAAMC,GAAN;AAAA,SAAc,UAAAJ,CAAC;AAAA,WAAIK,IAAI,CAACF,GAAL,CAASE,IAAI,CAACD,GAAL,CAASD,GAAT,EAAcH,CAAd,CAAT,EAA2BI,GAA3B,CAAJ;AAAA,GAAf;AAAA,CAAd,EAEP;;;;AACO,IAAME,UAAU,GAAG,oBAAO,UAACH,GAAD,EAAMC,GAAN,EAAWG,EAAX;AAAA,SAAkB,sBAAQL,KAAK,CAACC,GAAD,EAAMC,GAAN,CAAb,EAAyBG,EAAzB,CAAlB;AAAA,CAAP,CAAnB,EAEP;;;;AACO,IAAMC,IAAI,GAAG,SAAPA,IAAO,CAACC,GAAD,EAAMF,EAAN;AAAA,SAAaV,MAAM,CAAC,2CAAYY,GAAZ,EAAkBF,EAAlB,EAAD,CAAnB;AAAA,CAAb;;;;;;;;;;;ACpBP;;AAEA;AACA,IAAMG,UAAU,GAAG,yBAAW,CAAX,EAAc,CAAd,CAAnB,EAEA;;AACO,IAAMC,OAAO,GAAG,SAAVA,OAAU;AAAA,SAAM,mBAAK,MAAL,EAAaD,UAAU,CAACT,YAAD,CAAvB,CAAN;AAAA,CAAhB,EAEP;;;;;AACO,IAAMW,QAAQ,GAAG,SAAXA,QAAW;AAAA,SAAM,mBAAK,OAAL,EAAcF,UAAU,CAACX,YAAD,CAAxB,CAAN;AAAA,CAAjB;;;;;;ACTP;;AAEA,IAAMc,KAAK,GAAG;AACV,UAAQ,CADE;AAEV,WAAS;AAFC,CAAd;AAKAC,OAAO,CAACC,GAAR,CACI,uBACKC,KADL,CACWJ,gBADX,EAEKK,QAFL,CAEcJ,KAFd,CADJ","file":"redux-and-the-state-adt.e31bb0bc.map","sourceRoot":"..","sourcesContent":["/** @license ISC License (c) copyright 2017 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar fulfills =\n  function (algs) { return function (test) { return algs.indexOf(test) !== -1; }; }\n\nmodule.exports = fulfills\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nfunction isArray(x) {\n  return Array.isArray(x)\n}\n\nmodule.exports = isArray\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\n// isFunction : a -> Boolean\nfunction isFunction(fn) {\n  return typeof fn === 'function'\n}\n\nmodule.exports = isFunction\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar toString = Object.prototype.toString\n\n// isObject : a -> Boolean\nfunction isObject(x) {\n  return !!x\n    && toString.call(x) === '[object Object]'\n}\n\nmodule.exports = isObject\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\n// isString : a -> Boolean\nfunction isString(x) {\n  return typeof x === 'string'\n}\n\nmodule.exports = isString\n","/** @license ISC License (c) copyright 2018 original and current authors */\n/** @author Robert Pearce (rpearce) */\n\n// isSymbol : a -> Boolean\nfunction isSymbol(x) {\n  return typeof x === 'symbol'\n}\n\nmodule.exports = isSymbol\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar isArray = require('./isArray')\nvar isFunction = require('./isFunction')\nvar isObject = require('./isObject')\nvar isString = require('./isString')\nvar isSymbol = require('./isSymbol')\n\nfunction arrayInspect(xs) {\n  return xs.length\n    ? xs.map(inspect).reduce(function (a, x) { return a + ',' + x; })\n    : xs\n}\n\n// inspect : a -> String\nfunction inspect(x) {\n  if(x && isFunction(x.inspect)) {\n    return (\" \" + (x.inspect()))\n  }\n\n  if(isFunction(x)) {\n    return ' Function'\n  }\n\n  if(isArray(x)) {\n    return (\" [\" + (arrayInspect(x)) + \" ]\")\n  }\n\n  if(isObject(x)) {\n    return (\" { \" + (Object.keys(x).reduce(function (acc, key) {\n      return acc.concat([ (key + \":\" + (inspect(x[key]))) ])\n    }, []).join(', ')) + \" }\")\n  }\n\n  if(isString(x)) {\n    return (\" \\\"\" + x + \"\\\"\")\n  }\n\n  if(isSymbol(x)) {\n    return (\" \" + (x.toString()))\n  }\n\n  return (\" \" + x)\n}\n\nmodule.exports = inspect\n","/** @license ISC License (c) copyright 2017 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar _types = {\n  'unk': function () { return 'unknown'; },\n  'All': function () { return 'All'; },\n  'Any': function () { return 'Any'; },\n  'Arrow': function () { return 'Arrow'; },\n  'Assign': function () { return 'Assign'; },\n  'Async': function () { return 'Async'; },\n  'Const': function (inner) { return (\"Const(\" + inner + \")\"); },\n  'Either': function () { return 'Either'; },\n  'Endo': function () { return 'Endo'; },\n  'Equiv': function () { return 'Equiv'; },\n  'First': function () { return 'First'; },\n  'Identity': function () { return 'Identity'; },\n  'IO': function () { return 'IO'; },\n  'Last': function () { return 'Last'; },\n  'List': function () { return 'List'; },\n  'Max': function () { return 'Max'; },\n  'Maybe': function () { return 'Maybe'; },\n  'Min': function () { return 'Min'; },\n  'Pair': function () { return 'Pair'; },\n  'Pred': function () { return 'Pred'; },\n  'Prod': function () { return 'Prod'; },\n  'Reader': function () { return 'Reader'; },\n  'Result': function () { return 'Result'; },\n  'Star': function () { return 'Star'; },\n  'State': function () { return 'State'; },\n  'Sum': function () { return 'Sum'; },\n  'Tuple': function (n) { return (n + \"-Tuple\"); },\n  'Unit': function () { return 'Unit'; },\n  'Writer': function () { return 'Writer'; }\n}\n\nvar type =\n  function (type) { return _types[type] || _types['unk']; }\n\nvar proxy =\n  function (t, ctx) { return ({ type: function () { return type(t)(ctx); } }); }\n\nvar typeFn = function (t, ver, ctx) {\n  var typeStr = type(t)(ctx)\n  return (\"crocks/\" + typeStr + \"@\" + (ver || 0))\n}\n\nmodule.exports = {\n  proxy: proxy, type: type, typeFn: typeFn\n}\n","/** @license ISC License (c) copyright 2018 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nmodule.exports = {\n  alt: 'fantasy-land/alt',\n  bimap: 'fantasy-land/bimap',\n  chain: 'fantasy-land/chain',\n  compose: 'fantasy-land/compose',\n  concat: 'fantasy-land/concat',\n  contramap: 'fantasy-land/contramap',\n  empty: 'fantasy-land/empty',\n  equals: 'fantasy-land/equals',\n  extend: 'fantasy-land/extend',\n  id: 'fantasy-land/id',\n  map: 'fantasy-land/map',\n  of: 'fantasy-land/of',\n  promap: 'fantasy-land/promap',\n  reduce: 'fantasy-land/reduce',\n  zero: 'fantasy-land/zero'\n}\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar isFunction = require('./isFunction')\n\nfunction applyCurry(fn, arg) {\n  if(!isFunction(fn)) { return fn }\n  return fn.length > 1 ? fn.bind(null, arg) : fn.call(null, arg)\n}\n\n// curry : ((a, b, c) -> d) -> a -> b -> c -> d\nfunction curry(fn) {\n  return function() {\n    var xs = [], len = arguments.length;\n    while ( len-- ) xs[ len ] = arguments[ len ];\n\n    var args =\n      xs.length ? xs : [ undefined ]\n\n    if(args.length < fn.length) {\n      return curry(Function.bind.apply(fn, [ null ].concat(args)))\n    }\n\n    var val = args.length === fn.length\n      ? fn.apply(null, args)\n      : args.reduce(applyCurry, fn)\n\n    if(isFunction(val)) {\n      return curry(val)\n    }\n\n    return val\n  }\n}\n\nmodule.exports = curry\n","/** @license ISC License (c) copyright 2017 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar isFunction = require('./isFunction')\n\nfunction type(x) {\n  if(x) {\n    if(isFunction(x.type)) {\n      return x.type()\n    }\n  }\n  return {}.toString.call(x).slice(8, -1)\n}\n\nmodule.exports = type\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar curry = require('./curry')\nvar isFunction = require('./isFunction')\nvar type = require('./type')\n\n// isSameType :: Container m => (m, m) -> Boolean\nfunction isSameType(x, y) {\n  var tX = type(x)\n  var tY = type(y)\n\n  return tX === tY\n    || isFunction(x) && x.name === tY\n    || isFunction(y) && y.name === tX\n}\n\nmodule.exports = curry(isSameType)\n","/** @license ISC License (c) copyright 2017 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\n// isSame : (a, b) -> Boolean\nfunction isSame(x, y) {\n  if(x === y) {\n    return x !== 0 || 1 / x === 1 / y\n  }\n\n  return x !== x && y !== y\n}\n\nmodule.exports = isSame\n","/** @license ISC License (c) copyright 2017 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar isFunction = require('./isFunction')\nvar fl = require('./flNames')\n\nvar check = function (alg, m) { return isFunction(m[fl[alg]]) || isFunction(m[alg]); }\n\nvar checkImpl = function (alg, m) { return isFunction(m['@@implements']) && !!m['@@implements'](alg); }\n\nvar hasAlg = function (alg, m) { return !!m && (check(alg, m) || checkImpl(alg, m)); }\n\nmodule.exports = hasAlg\n","/** @license ISC License (c) copyright 2017 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar isSameType = require('./isSameType')\nvar isSame = require('./isSame')\nvar hasAlg = require('./hasAlg')\nvar type = require('./type')\nvar fl = require('./flNames')\n\nvar comp = function (a, b) { return a.valueOf() === b.valueOf(); }\n\nvar strats = {\n  'Array': function (a, b) { return a.length === b.length\n      && deepEquals(a, b); },\n\n  'Date': function (a, b) { return isSame(a.valueOf(), b.valueOf()); },\n\n  'Error': function (a, b) { return a.name === b.name\n      && a.message === b.message; },\n\n  'Object': function (a, b) { return Object.keys(a).length === Object.keys(b).length\n      && deepEquals(a, b); },\n\n  'RegExp': function (a, b) { return a.source === b.source\n      && a.ignoreCase === b.ignoreCase\n      && a.global === b.global\n      && a.multiline === b.multiline\n      && a.unicode === b.unicode; }\n}\n\nfunction deepEquals(a, b) {\n  for(var key in a) {\n    if(!equals(a[key], b[key])) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction equals(a, b) {\n  if(isSame(a, b)) {\n    return true\n  }\n\n  if(!isSameType(a, b)) {\n    return false\n  }\n\n  if(hasAlg('equals', a)) {\n    return (b[fl.equals] || b.equals).call(b, a)\n  }\n\n  return (strats[type(a)] || comp)(a, b)\n}\n\nmodule.exports = equals\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar hasAlg = require('./hasAlg')\n\n// isFunctor : a -> Boolean\nfunction isFunctor(m) {\n  return !!m && hasAlg('map', m)\n}\n\nmodule.exports = isFunctor\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar hasAlg = require('./hasAlg')\nvar isFunctor = require('./isFunctor')\n\n// isApply : a -> Boolean\nfunction isApply(m) {\n  return isFunctor(m)\n    && hasAlg('ap', m)\n}\n\nmodule.exports = isApply\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar hasAlg = require('./hasAlg')\nvar isApply = require('./isApply')\n\n// isApplicative : a -> Boolean\nfunction isApplicative(m) {\n  return isApply(m)\n    && (hasAlg('of', m) || hasAlg('of', m.constructor))\n}\n\nmodule.exports = isApplicative\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar isString = require('./isString')\nvar hasAlg = require('./hasAlg')\n\n// isSemigroup : a -> Boolean\nfunction isSemigroup(m) {\n  return isString(m)\n    || !!m && hasAlg('concat', m)\n}\n\nmodule.exports = isSemigroup\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar VERSION = 4\n\nvar _equals = require('./equals')\nvar _implements = require('./implements')\nvar _inspect = require('./inspect')\nvar type = require('./types').type('Pair')\nvar _type = require('./types').typeFn(type(), VERSION)\nvar fl = require('./flNames')\n\nvar isApplicative = require('./isApplicative')\nvar isApply = require('./isApply')\nvar isArray = require('./isArray')\nvar isFunction = require('./isFunction')\nvar isSameType = require('./isSameType')\nvar isSemigroup = require('./isSemigroup')\n\nfunction Pair(l, r) {\n  var obj;\n\n  if(arguments.length < 2) {\n    throw new TypeError('Pair: Must provide a first and second value')\n  }\n\n  var fst =\n    function () { return l; }\n\n  var snd =\n    function () { return r; }\n\n  var inspect =\n    function () { return (\"Pair(\" + (_inspect(l)) + \",\" + (_inspect(r)) + \" )\"); }\n\n  var toArray =\n    function () { return [ l, r ]; }\n\n  function merge(fn) {\n    if(!isFunction(fn)) {\n      throw new TypeError('Pair.merge: Binary function required')\n    }\n\n    return fn(fst(), snd())\n  }\n\n  function equals(m) {\n    return isSameType(Pair, m)\n      && _equals(m.fst(), fst())\n      && _equals(m.snd(), snd())\n  }\n\n  function concat(method) {\n    return function(m) {\n      if(!isSameType(Pair, m)) {\n        throw new TypeError((\"Pair.\" + method + \": Pair required\"))\n      }\n\n      var lf = fst()\n      var ls = snd()\n      var rf = m.fst()\n      var rs = m.snd()\n\n      if(!(isSemigroup(lf) && isSemigroup(ls))) {\n        throw new TypeError((\"Pair.\" + method + \": Both Pairs must contain Semigroups of the same type\"))\n      }\n\n      if(!(isSameType(lf, rf) && isSameType(ls, rs))) {\n        throw new TypeError((\"Pair.\" + method + \": Both Pairs must contain Semigroups of the same type\"))\n      }\n\n      return Pair(\n        lf.concat(rf),\n        ls.concat(rs)\n      )\n    }\n  }\n\n  function swap(f, g) {\n    if(!isFunction(f) || !isFunction(g)) {\n      throw new TypeError('Pair.swap: Requires both left and right functions')\n    }\n\n    return Pair(g(r), f(l))\n  }\n\n  function map(method) {\n    return function(fn) {\n      if(!isFunction(fn)) {\n        throw new TypeError((\"Pair.\" + method + \": Function required\"))\n      }\n\n      return Pair(l, fn(r))\n    }\n  }\n\n  function bimap(method) {\n    return function(f, g) {\n      if(!isFunction(f) || !isFunction(g)) {\n        throw new TypeError((\"Pair.\" + method + \": Function required for both arguments\"))\n      }\n\n      return Pair(f(l), g(r))\n    }\n  }\n\n  function ap(m) {\n    if(!isSameType(Pair, m)) {\n      throw new TypeError('Pair.ap: Pair required')\n    }\n\n    var fn = snd()\n\n    if(!isFunction(fn)) {\n      throw new TypeError('Pair.ap: Function required for second value')\n    }\n\n    var l = fst()\n    var r = m.fst()\n\n    if(!(isSemigroup(l) && isSameType(l, r))) {\n      throw new TypeError('Pair.ap: Semigroups of the same type is required for first values')\n    }\n\n    return Pair(l.concat(r), fn(m.snd()))\n  }\n\n  function chain(method) {\n    return function(fn) {\n      var l = fst()\n\n      if(!isFunction(fn)) {\n        throw new TypeError((\"Pair.\" + method + \": Function required\"))\n      }\n\n      if(!isSemigroup(l)) {\n        throw new TypeError((\"Pair.\" + method + \": Semigroups of the same type required for first values\"))\n      }\n\n      var m = fn(snd())\n\n      if(!isSameType(Pair, m)) {\n        throw new TypeError((\"Pair.\" + method + \": Function must return a Pair\"))\n      }\n\n      var r = m.fst()\n\n      if(!isSameType(l, r)) {\n        throw new TypeError((\"Pair.\" + method + \": Semigroups of the same type required for first values\"))\n      }\n\n      return Pair(\n        l.concat(r),\n        m.snd()\n      )\n    }\n  }\n\n  function sequence(f) {\n    if(!(isApplicative(f) || isFunction(f))) {\n      throw new TypeError(\n        'Pair.sequence: Applicative TypeRep or Apply returning function required'\n      )\n    }\n\n    if(!(isApply(r) || isArray(r))) {\n      throw new TypeError(\n        'Pair.sequence: Must wrap an Apply in the second'\n      )\n    }\n\n    return r.map(function (v) { return Pair(l, v); })\n  }\n\n  function traverse(f, fn) {\n    if(!(isApplicative(f) || isFunction(f))) {\n      throw new TypeError(\n        'Pair.traverse: Applicative TypeRep or Apply returning function required for first argument'\n      )\n    }\n\n    if(!isFunction(fn)) {\n      throw new TypeError(\n        'Pair.traverse: Apply returning function required for second argument'\n      )\n    }\n\n    var m = fn(r)\n\n    if(!(isApply(m) || isArray(m))) {\n      throw new TypeError(\n        'Pair.traverse: Both functions must return an Apply of the same type'\n      )\n    }\n\n    return m.map(function (v) { return Pair(l, v); })\n  }\n\n  function extend(method) {\n    return function(fn) {\n      if(!isFunction(fn)) {\n        throw new TypeError((\"Pair.\" + method + \": Function required\"))\n      }\n\n      return Pair(l, fn(Pair(l, r)))\n    }\n  }\n\n  return ( obj = {\n    inspect: inspect, toString: inspect, fst: fst,\n    snd: snd, toArray: toArray, type: type, merge: merge, equals: equals,\n    swap: swap, ap: ap, sequence: sequence, traverse: traverse,\n    concat: concat('concat'),\n    map: map('map'),\n    bimap: bimap('bimap'),\n    chain: chain('chain'),\n    extend: extend('extend')\n  }, obj[fl.equals] = equals, obj[fl.concat] = concat(fl.concat), obj[fl.map] = map(fl.map), obj[fl.bimap] = bimap(fl.bimap), obj[fl.chain] = chain(fl.chain), obj[fl.extend] = extend(fl.extend), obj['@@type'] = _type, obj.constructor = Pair, obj )\n}\n\nPair.type = type\nPair['@@type'] = _type\n\nPair['@@implements'] = _implements(\n  [ 'ap', 'bimap', 'chain', 'concat', 'extend', 'equals', 'map', 'traverse' ]\n)\n\nmodule.exports = Pair\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar VERSION = 2\n\nvar _implements = require('./implements')\nvar type = require('./types').type('Unit')\nvar _type = require('./types').typeFn(type(), VERSION)\nvar fl = require('./flNames')\n\nvar isFunction = require('./isFunction')\nvar isSameType = require('./isSameType')\n\nvar _of =\n  Unit\n\nvar _empty =\n  Unit\n\nfunction Unit() {\n  var obj;\n\n  var equals =\n    function (m) { return isSameType(Unit, m); }\n\n  var inspect =\n    function () { return '()'; }\n\n  var valueOf =\n    function () { return undefined; }\n\n  var of =\n    _of\n\n  var empty =\n    _empty\n\n  function concat(method) {\n    return function(m) {\n      if(!isSameType(Unit, m)) {\n        throw new TypeError((\"Unit.\" + method + \": Unit required\"))\n      }\n\n      return Unit()\n    }\n  }\n\n  function map(method) {\n    return function(fn) {\n      if(!isFunction(fn)) {\n        throw new TypeError((\"Unit.\" + method + \": Function required\"))\n      }\n\n      return Unit()\n    }\n  }\n\n  function ap(m) {\n    if(!isSameType(Unit, m)) {\n      throw new TypeError('Unit.ap: Unit required')\n    }\n\n    return Unit()\n  }\n\n  function chain(method) {\n    return function(fn) {\n      if(!isFunction(fn)) {\n        throw new TypeError((\"Unit.\" + method + \": Function required\"))\n      }\n\n      return Unit()\n    }\n  }\n\n  return ( obj = {\n    inspect: inspect, toString: inspect, valueOf: valueOf,\n    type: type, equals: equals, empty: empty, ap: ap, of: of,\n    concat: concat('concat'),\n    map: map('map'),\n    chain: chain('chain')\n  }, obj[fl.of] = of, obj[fl.empty] = empty, obj[fl.equals] = equals, obj[fl.concat] = concat(fl.concat), obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj['@@type'] = _type, obj.constructor = Unit, obj )\n}\n\nUnit.of = _of\nUnit.empty = _empty\nUnit.type = type\n\nUnit[fl.of] = _of\nUnit[fl.empty] = _empty\nUnit['@@type'] = _type\n\nUnit['@@implements'] = _implements(\n  [ 'ap', 'chain', 'concat', 'empty', 'equals', 'map', 'of' ]\n)\n\nmodule.exports = Unit\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar VERSION = 2\n\nvar _implements = require('../core/implements')\nvar _inspect = require('../core/inspect')\nvar type = require('../core/types').type('State')\nvar _type = require('../core/types').typeFn(type(), VERSION)\nvar fl = require('../core/flNames')\n\nvar Pair = require('../core/Pair')\nvar Unit = require('../core/Unit')\n\nvar isFunction = require('../core/isFunction')\nvar isSameType = require('../core/isSameType')\n\nvar _of =\n  function (x) { return State(function (s) { return Pair(x, s); }); }\n\nfunction get(fn) {\n  if(!arguments.length) {\n    return State(function (s) { return Pair(s, s); })\n  }\n\n  if(isFunction(fn)) {\n    return State(function (s) { return Pair(fn(s), s); })\n  }\n\n  throw new TypeError('State.get: No arguments or function required')\n}\n\nfunction modify(fn) {\n  if(!isFunction(fn)) {\n    throw new TypeError('State.modify: Function Required')\n  }\n\n  return State(function (s) { return Pair(Unit(), fn(s)); })\n}\n\nfunction State(fn) {\n  var obj;\n\n  if(!isFunction(fn)) {\n    throw new TypeError('State: Must wrap a function in the form (s -> Pair a s)')\n  }\n\n  var of =\n    _of\n\n  var inspect =\n    function () { return (\"State\" + (_inspect(fn))); }\n\n  function runWith(state) {\n    var params = [], len = arguments.length - 1;\n    while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];\n\n    var func = params[0]; if ( func === void 0 ) func = 'runWith';\n    var m = fn(state)\n\n    if(!isSameType(Pair, m)) {\n      throw new TypeError((\"State.\" + func + \": Must wrap a function in the form (s -> Pair a s)\"))\n    }\n\n    return m\n  }\n\n  function execWith(s) {\n    var pair = runWith(s, 'execWith')\n    return pair.snd()\n  }\n\n  function evalWith(s) {\n    var pair = runWith(s, 'evalWith')\n    return pair.fst()\n  }\n\n  function map(method) {\n    return function(fn) {\n      if(!isFunction(fn)) {\n        throw new TypeError((\"State.\" + method + \": Function required\"))\n      }\n\n      return State(function (s) {\n        var m = runWith(s, method)\n        return Pair(fn(m.fst()), m.snd())\n      })\n    }\n  }\n\n  function ap(m) {\n    if(!isSameType(State, m)) {\n      throw new TypeError('State.ap: State required')\n    }\n\n    return State(function (s) {\n      var pair = runWith(s, 'ap')\n      var fn = pair.fst()\n\n      if(!isFunction(fn)) {\n        throw new TypeError('State.ap: Source value must be a function')\n      }\n\n      return m.map(fn).runWith(pair.snd())\n    })\n  }\n\n  function chain(method) {\n    return function(fn) {\n      if(!isFunction(fn)) {\n        throw new TypeError((\"State.\" + method + \": State returning function required\"))\n      }\n\n      return State(function (s) {\n        var pair = runWith(s, method)\n        var m = fn(pair.fst())\n\n        if(!isSameType(State, m)) {\n          throw new TypeError((\"State.\" + method + \": Function must return another State\"))\n        }\n\n        return m.runWith(pair.snd())\n      })\n    }\n  }\n\n  return ( obj = {\n    inspect: inspect, toString: inspect, runWith: runWith,\n    execWith: execWith, evalWith: evalWith, type: type, ap: ap, of: of,\n    map: map('map'),\n    chain: chain('chain')\n  }, obj[fl.of] = of, obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj['@@type'] = _type, obj.constructor = State, obj )\n}\n\nState.of = _of\nState.get = get\n\nState.modify = modify\n\nState.put =\n  function (x) { return modify(function () { return x; }); }\n\nState.type = type\n\nState[fl.of] = _of\nState['@@type'] = _type\n\nState['@@implements'] = _implements(\n  [ 'ap', 'chain', 'map', 'of' ]\n)\n\nmodule.exports = State\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar _curry = require('../core/curry')\nvar isFunction = require('../core/isFunction')\n\n// curry : ((a, b, c) -> d) -> a -> b -> c -> d\nfunction curry(fn) {\n  if(!isFunction(fn)) {\n    throw new TypeError('curry: Function required')\n  }\n\n  return _curry(fn)\n}\n\nmodule.exports = curry\n","/** @license ISC License (c) copyright 2016 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar isFunction = require('../core/isFunction')\n\nvar err = 'compose: Functions required'\n\nfunction applyPipe(f, g) {\n  if(!isFunction(g)) {\n    throw new TypeError(err)\n  }\n\n  return function () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return g.call(null, f.apply(null, args));\n  }\n}\n\n// compose : ((y -> z), (x -> y), ..., (a -> b)) -> a -> z\nfunction compose() {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  if(!arguments.length) {\n    throw new TypeError(err)\n  }\n\n  var fns =\n    args.slice().reverse()\n\n  var head =\n    fns[0]\n\n  if(!isFunction(head)) {\n    throw new TypeError(err)\n  }\n\n  var tail =\n    fns.slice(1).concat(function (x) { return x; })\n\n  return tail.reduce(applyPipe, head)\n}\n\nmodule.exports = compose\n","/** @license ISC License (c) copyright 2017 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\n// isNil : a -> Boolean\nfunction isNil(x) {\n  return x === undefined\n    || x === null\n    || Number.isNaN(x)\n}\n\nmodule.exports = isNil\n","/** @license ISC License (c) copyright 2017 original and current authors */\n/** @author Ian Hofmann-Hicks (evil) */\n\nvar curry = require('../core/curry')\nvar isObject = require('../core/isObject')\nvar isFunction = require('../core/isFunction')\nvar isNil = require('../core/isNil')\n\n// applyMap :: ({ (* -> *) }, Object) -> (Object , String) -> Object\nvar applyMap = function (fns, obj) { return function(acc, key) {\n    var obj$1, obj$2, obj$3;\n\n    if(isNil(fns[key])) {\n      return Object.assign({}, acc, ( obj$1 = {}, obj$1[key] = obj[key], obj$1 ))\n    }\n\n    if(isObject(fns[key])) {\n      return Object.assign({}, acc, ( obj$2 = {}, obj$2[key] = isObject(obj[key]) ? mapProps(fns[key], obj[key]) : obj[key], obj$2 ))\n    }\n\n    if(!isFunction(fns[key])) {\n      throw new TypeError('mapProps: Object of functions required for first argument')\n    }\n\n    return Object.assign({}, acc, ( obj$3 = {}, obj$3[key] = fns[key](obj[key]), obj$3 ))\n  }; }\n\n// mapProps :: { (* -> *) } -> Object -> Object\nfunction mapProps(fns, obj) {\n  if(!(isObject(fns) && isObject(obj))) {\n    throw new TypeError('mapProps: Objects required for both arguments')\n  }\n\n  return Object.keys(obj)\n    .reduce(applyMap(fns, obj), {})\n}\n\nmodule.exports = curry(mapProps)\n","import State from 'crocks/State'\nimport curry from 'crocks/helpers/curry'\nimport compose from 'crocks/helpers/compose'\nimport mapProps from 'crocks/helpers/mapProps'\n\nconst { modify} = State\n\n// inc :: Number -> Number\nexport const inc = x => x += 1\n\n// dec :: Number -> Number\nexport const dec = x => x -= 1\n\n// clamp :: (Number, Number) -> Number -> Number\nexport const clamp = (min, max) => x => Math.min(Math.max(min, x), max)\n\n// clampAfter :: Number -> Number -> (a -> Number) -> a -> Number\nexport const clampAfter = curry( (min, max, fn) => compose(clamp(min, max), fn))\n\n// over :: (String, (a -> b)) -> Object -> State Object ()\nexport const over = (key, fn) => modify(mapProps({ [key]: fn}))\n","import { clampAfter, dec, over, inc } from '../helpers'\n\n// limitMoves :: (a -> Number) -> a -> Number\nconst limitMoves = clampAfter(0, 8)\n\n// decLeft :: () -> State AppState ()\nexport const decLeft = () => over('left', limitMoves(dec))\n\n// incMoves :: () -> State AppState ()\nexport const incMoves = () => over('moves', limitMoves(inc))\n","import { decLeft, incMoves } from './data/model/answer'\n\nconst state = {\n    'left': 8,\n    'moves': 0\n}\n\nconsole.log(\n    decLeft()\n        .chain(incMoves)\n        .execWith(state)\n)\n"]}